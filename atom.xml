<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Radiantzy.github.io</id>
    <title>Radiantz</title>
    <updated>2022-06-08T06:50:04.474Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Radiantzy.github.io"/>
    <link rel="self" href="https://Radiantzy.github.io/atom.xml"/>
    <subtitle>帮助自己收获更多的地方！</subtitle>
    <logo>https://Radiantzy.github.io/images/avatar.png</logo>
    <icon>https://Radiantzy.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Radiantz</rights>
    <entry>
        <title type="html"><![CDATA[基于S7-1500的单步六层电梯教程]]></title>
        <id>https://Radiantzy.github.io/post/ji-yu-s7-1500-de-dan-bu-liu-ceng-dian-ti-jiao-cheng/</id>
        <link href="https://Radiantzy.github.io/post/ji-yu-s7-1500-de-dan-bu-liu-ceng-dian-ti-jiao-cheng/">
        </link>
        <updated>2022-06-08T06:35:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="相关软件和资料下载">相关软件和资料下载</h1>
<h2 id="西门子竞赛官网关于2020单步六层电梯"><a href="http://www.siemenscup-cimc.org.cn/Project/PorjectResourceDetail?id=2">西门子竞赛官网（关于2020单步六层电梯）</a></h2>
<h2 id="博途v16软件官网下载"><a href="https://support.industry.siemens.com/cs/document/109772803/simatic-step-7-incl-safety-and-wincc-v16-trial-download?dti=0&amp;dl=en&amp;lc=zh-CN">博途v16软件官网下载</a></h2>
<p><strong>博途软件是比较难装的，我自己都经常装到蓝屏或者反复开关机，可以选择看<a href="https://blog.csdn.net/qq_37424623/article/details/118099796?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165464816616780357227917%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165464816616780357227917&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-118099796-null-null.142%5Ev11%5Epc_search_result_control_group,157%5Ev13%5Econtrol&amp;utm_term=%E5%8D%9A%E9%80%94v16%E4%B8%8B%E8%BD%BD&amp;spm=1018.2226.3001.4187">教程</a>下载或者找万能某宝代下~</strong></p>
<p>在下载链接内看到这个，或者下DVD2,DVD3都一样<br>
<img src="https://Radiantzy.github.io/post-images/1654670501389.png" alt="" loading="lazy"></p>
<p><strong>注意这个下完了之后应该会出现很多个plc的图标，安啦安啦，我们主要是用TIA Portal V16</strong></p>
<figure data-type="image" tabindex="1"><img src="https://Radiantzy.github.io/post-images/1654670515046.png" alt="" loading="lazy"></figure>
<h2 id="软plc下载"><a href="https://pan.baidu.com/s/170b_cJ_jPsfmPbi88YjRlQ?pwd=2ndi">软plc下载</a>  提取码：2ndi</h2>
<p>该软件安装完成后得到PLCSIM Advanced2.0</p>
<figure data-type="image" tabindex="2"><img src="https://Radiantzy.github.io/post-images/1654670526653.png" alt="" loading="lazy"></figure>
<h2 id="eet-basic电梯仿真软件下载"><a href="http://bbs.siemenscup-cimc.org.cn/forum.php?mod=viewthread&amp;tid=4183&amp;extra=">EET Basic电梯仿真软件下载</a></h2>
<p>该软件安装完成后对应界面如下：<br>
<img src="https://Radiantzy.github.io/post-images/1654670537031.png" alt="" loading="lazy"><br>
<strong>注意，要完成单步六层电梯的操作，以下几个图标是必须有的，wincc和对应许可证的图标可以没有</strong><br>
<img src="https://Radiantzy.github.io/post-images/1654670545641.png" alt="" loading="lazy"></p>
<h1 id="单步六层电梯程序块及逻辑分块介绍">单步六层电梯程序块及逻辑分块介绍</h1>
<p><strong>教程适应于有plc操作基础的小白，指只是对电梯编程逻辑不清楚的小白，不适合连plc基本操作都不会的小白，那样的话需要先学习博途软件的使用，贴个<a href="https://www.bilibili.com/video/BV1Mb4y1X7BR?spm_id_from=333.337.search-card.all.click">学习链接</a></strong></p>
<p><strong>也可以自行去b站搜教程，对应cctalk也有相关教程</strong></p>
<p><strong>我是二次咀嚼前人的东西，然后自己融合一点心得体会写了一点，后面课设遇到什么问题还会在程序中更新，贴一个<a href="https://blog.csdn.net/qq_44808429/article/details/114574368?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165452460016781667843976%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165452460016781667843976&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-114574368-null-null.142%5Ev11%5Epc_search_result_control_group,157%5Ev13%5Econtrol&amp;utm_term=plc%E5%8D%95%E6%AD%A5%E5%85%AD%E5%B1%82&amp;spm=1018.2226.3001.4187">前人链接</a>，相关<a href="http://www.demodashi.com/demo/17351.html">程序</a>，直接点下载源码就好了qwq</strong></p>
<h2 id="电梯初始化程序块介绍">电梯初始化程序块介绍</h2>
<h3 id="程序内涉及名词介绍">程序内涉及名词介绍</h3>
<p>因为程序中的一些注释是为了方便区分和简单的意思命名的，我后面会用大白话解释一下例如一些（上平层下平层信号的）意思。</p>
<p>首先我们来了解一下电梯结构<br>
<img src="https://Radiantzy.github.io/post-images/1654670560213.png" alt="" loading="lazy"></p>
<ul>
<li><strong>上（下）平层传感器</strong>：可以理解为定位电梯位置，比如上下平层都卡到了5层轿厢应该到的位置，那么同时置1就代表轿厢到了5层啦！</li>
<li><strong>上（下）端站第一（二）限位</strong>：这个是为了限制电梯轿厢不能持续向上（或者向下走），当传感器碰到这个位置置1后代表到了底层（或顶层）</li>
<li><strong>自动运行信号</strong>：官方给的自启动信号</li>
<li><strong>准备就绪信号</strong>：电梯自行完成初始化后输出已经完成初始化</li>
</ul>
<p>线上赛开始，官方给出自动运行信号示意开始，控制程序收到该信号后进行一系列初始化，之后发出“准备就绪”信号以示确认（eg：使电梯位于基站（1层）待命）</p>
<p>输入的自动运行信号：脉冲信号</p>
<p>输出的准备就绪信号为：持续的长信号</p>
<ul>
<li>
<p><strong>初始化目的</strong>：plc起初不知道电梯停在第几层，让plc知道目前电梯在第几层</p>
</li>
<li>
<p><strong>初始化结果</strong>：初始化到目标楼层，以准备就绪信号代表初始化完成</p>
</li>
</ul>
<h3 id="逻辑说明">逻辑说明</h3>
<p><strong>向下初始化为1层具体做法</strong>：（向上是一样的逻辑）</p>
<ol>
<li>
<p>plc捕获到电梯自动运行信号，低速向下行驶（此时记得禁止高速表示严谨）</p>
</li>
<li>
<p>需要让下行指令置1，表示在向下走，打开下行接触器，关闭上行接触器<br>
<img src="https://Radiantzy.github.io/post-images/1654670783660.png" alt="" loading="lazy"><br>
（这里需要强调下，上行接触器目的跟上平层接触器是一样的，就是定位电梯位置的qwq，下行同理）</p>
<p><strong>另外有一点是需要明白的：上行命令是外界给的，统一完后给上行指示给plc，有很多种情况都会导致电梯上行，为了保证严谨性还是先汇总各种情况，再统一给plc发出上行指示，后期看程序也好纠错。</strong></p>
</li>
<li>
<p>当向下碰到下端点第一限位，即换速，plc捕获到该限位由0-1，则改低速向上，示意到底了不能再往下降了</p>
</li>
<li>
<p>此时不能继续下行，置0下行指示，置1上行指示（即低速上行），接触器同样设置好置0/1信号</p>
</li>
<li>
<p>发出向上回一楼信号</p>
</li>
<li>
<p>关闭向下初始化信号<br>
<img src="https://Radiantzy.github.io/post-images/1654670720816.png" alt="" loading="lazy"></p>
</li>
</ol>
<p><strong>准备就绪信号的触发</strong></p>
<ol>
<li>当上平层传感器由0→1，电梯依次开始3级制动（即1，2，3级减速）</li>
<li>当下平层传感器由0→1，表示电梯刚好就在这一层</li>
<li>注意。1，2条要同时触发才能确定轿厢就停在了某一层</li>
<li>此时所停层即准备就绪信号</li>
</ol>
<p>哦，具体程序中，到某一层后要记得打开风扇，照明（细节问题）</p>
<h2 id="数码管显示程序块">数码管显示程序块</h2>
<ol>
<li>先用abcdefg表示六个楼层的灯，这里就是数码管点亮数字</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://Radiantzy.github.io/post-images/1654670796829.png" alt="" loading="lazy"></figure>
<ol>
<li>然后就没了，也就是一个程序点灯。</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://Radiantzy.github.io/post-images/1654670822641.png" alt="" loading="lazy"></figure>
<h2 id="门锁信号程序块">门锁信号程序块</h2>
<ol>
<li><strong>轿厢门锁信号</strong>：轿厢锁门</li>
<li><strong>1-6层门锁信号</strong>：各层打开门</li>
</ol>
<h3 id="逻辑说明-2">逻辑说明</h3>
<p>为了保障安全，让电梯在各层及轿厢门锁信号都为1时开始运行，当轿厢门和各楼层的门都关好了，再去向上向下走</p>
<h2 id="开门信号程序块">开门信号程序块</h2>
<p><strong>电梯1-6层登记</strong>：确定电梯在第几层被需要，是一个确定信号，表示这一层被人需要了，需要让plc响应</p>
<p><strong>本层召唤开门信号</strong>：顾名思义就是开门</p>
<h3 id="逻辑说明-3">逻辑说明</h3>
<ol>
<li>
<p>当电梯到了指定楼层，且电梯静止（上下平层接触器均置0），此时打开电梯门</p>
</li>
<li>
<p>具体表明哪些情况会触发电梯x层登记：</p>
<ul>
<li>x层上（下）呼：即不是这层的电梯外部的人想到这层去</li>
<li>x层内呼指示灯：电梯内的人想到这层去，导致内呼灯亮</li>
</ul>
<p>两种情况都可以触发表明电梯此时在x层被需要。</p>
</li>
<li>
<p>当此时电梯在x层，且<strong>电梯x层登记</strong>这个信号被触发（置1），且没有<strong>上下接触器</strong>的启动（表明电梯此时是静止的）</p>
</li>
<li>
<p>触发本层开门信号</p>
</li>
</ol>
<figure data-type="image" tabindex="5"><img src="https://Radiantzy.github.io/post-images/1654670844129.png" alt="" loading="lazy"></figure>
<p><strong>通俗的说就是某层人想进电梯，他按了上或下，电梯会响应，响应信号是电梯x层登记，表示这层被需要了，或是电梯内的人想在x层出去，也会触发登记信号</strong></p>
<h2 id="上下行程序块">上下行程序块</h2>
<h3 id="逻辑说明-4">逻辑说明</h3>
<ol>
<li>
<p>首先要明白一点，上下行命令是外界给的，即<strong>人的需求</strong>，但是plc不能每一个信号都响应，所以把这些命令汇总给上下行指示，plc只需要识别上下行指示的信号有没有置1，那么就启动电机上行。</p>
</li>
<li>
<p>具体表明哪些情况会给plc发出<strong>上行指示</strong>（下行同，不赘述）</p>
<ul>
<li>上行命令：外呼/内呼要求上行</li>
<li>本层上行指示灯辅助：在电梯停靠层有人想上去</li>
</ul>
</li>
<li>
<p>其次分析一下具体可能导致<strong>上行命令</strong>触发的事件：</p>
<ul>
<li>你在2层，想上去，电梯在1层，得上来接你（以此类推）（<strong>是人跟电梯不同层</strong>）</li>
</ul>
</li>
<li>
<p>再来分析一下导致<strong>本层上行指示灯辅助</strong>置1的事件：（<strong>人跟电梯相同层</strong>）</p>
<ul>
<li>电梯既没有收到上行（或下行）命令，也没有触发上行（或下行）接触器，即显示电梯没有在运动，停靠在本层</li>
<li>有了上呼信号</li>
</ul>
</li>
<li>
<p><strong>一定要注意多设置限定条件。不能让逻辑冲突！！！</strong></p>
<p>即<strong>当给出上行命令时，就不能有本层上行指示灯辅助</strong>.</p>
</li>
</ol>
<h2 id="上下楼层计数程序块">上下楼层计数程序块</h2>
<p>问题：怎么确定轿厢就是到了某一层呢？</p>
<p>答：两件事情同时发生：</p>
<ul>
<li>上行接触器开（表示电梯一直在行走）且触发了上平层接触器，表示轿厢到了某层的顶</li>
<li>下行接触器开（表示电梯一直在行走）且触发了下平层接触器，表示轿厢到了某层的底</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://Radiantzy.github.io/post-images/1654670874070.png" alt="" loading="lazy"></figure>
<p>通俗一点说就是：<strong>轿厢跟楼层完全适配了</strong></p>
<p>那么电梯轿厢确定到了某一层。</p>
<p><strong>楼层是不会动的，只有轿厢在动，可以看电梯内部结构图，当轿厢的接触器识别到刚好匹配电梯的上下层，说明刚好就是在这一层，不上也不下。</strong></p>
<h2 id="按钮指示灯程序块">按钮指示灯程序块</h2>
<p>一部电梯除了有上下行指示外，还有电梯内呼按钮指示灯跟电梯外呼上下行按钮指示灯。</p>
<p><strong>平层信号</strong>：即将到目标层的上一层，需要做一些减速等的准备。</p>
<p>即<strong>当电梯上下过程中，经过的楼层中有楼层上呼（或内呼）信号触发，则平层信号置1，表示将在该楼层停层。</strong></p>
<h3 id="灯亮逻辑说明">灯亮逻辑说明</h3>
<ol>
<li>人在x层外，按了向上那么：<strong>a.</strong> <em><strong>x层外呼上行灯亮</strong></em>；**b. **x层上呼置1</li>
</ol>
<figure data-type="image" tabindex="7"><img src="https://Radiantzy.github.io/post-images/1654670895714.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>
<p>人在电梯内，按了x层，那么***x层内呼指示灯亮***</p>
</li>
<li>
<p>当没有人按按钮时，当前楼层上下平层信号都触发，表示电梯到了这层，那么***内呼指示灯灭***。</p>
</li>
</ol>
<h3 id="灯灭逻辑说明">灯灭逻辑说明</h3>
<ol>
<li>本层召唤开门信号置1，表示要开这层门那么***上下呼的信号就要灭***，因为已经准备开门了</li>
<li>要向上去的时候，下呼灯灭，向下去的时候，上呼灯灭。</li>
<li>电梯内的目标楼层，到了就灭</li>
</ol>
<h2 id="开关门程序块">开关门程序块</h2>
<p>电梯到达指定楼层需要开门，开门后需要持续一段时间自动关门</p>
<p>细节：超载或关门过程中有光幕（红外传感，人可能会临时堵门等）都要立即停止关门，重新触发开门接触器</p>
<h3 id="开门逻辑说明">开门逻辑说明</h3>
<ol>
<li>
<p>电梯停稳信号置1</p>
</li>
<li>
<p>本层召唤开门信号置1</p>
</li>
<li>
<p>已经在关门的时候重新触发开门有以下事件发生：</p>
<ul>
<li>轿内开门按钮被触发</li>
<li>有光幕信号产生</li>
<li>超载</li>
</ul>
<p>三种情况发生任何一种，都会重新触发开门继电器</p>
</li>
</ol>
<h3 id="关门逻辑说明">关门逻辑说明</h3>
<ol>
<li>同开门逻辑的相反，这里不过多赘述</li>
</ol>
<figure data-type="image" tabindex="8"><img src="https://Radiantzy.github.io/post-images/1654670918463.png" alt="" loading="lazy"></figure>
<p><strong>解读这段代码就是，解释什么事件会触发外呼下行灯灭，即当上下平层都置1，表示电梯已经到了目标层，且平层信号为1即触发了就在本层停，这种情况下要开门，所以外呼灯就会灭</strong></p>
<h3 id="开门锁上下行">开门锁上下行</h3>
<p>当电梯门打开的时候，为了安全起见，把电梯锁死，不能让电梯再上下行</p>
<p>即<strong>一开门，开门锁上下行信号就触发，当接受到关门到位信号后，开门锁上下行信号重新关闭，电梯可以重新启动</strong><br>
<img src="https://Radiantzy.github.io/post-images/1654670946314.png" alt="" loading="lazy"></p>
<h2 id="启停模块">启停模块</h2>
<h3 id="逻辑说明-5">逻辑说明</h3>
<ol>
<li>当上行命令触发后，确认没有什么故障情况（超载等）就打开上行接触器，开启低速运行</li>
<li>延时一段时间后，切换低速运行到高速运行</li>
<li>当上行到平层信号触发时（平层信号前面解释过了，就是目标楼层的上一层），就换低速运行。把前面涉及到的信号都复位。</li>
</ol>
<h2 id="三级制动模块">三级制动模块</h2>
<h3 id="逻辑说明-6">逻辑说明</h3>
<ol>
<li>
<p>延时延时再延时完成一二三级制动，SRSR不断替换</p>
</li>
<li>
<p>当上平层信号置1，下平层信号捕捉到上升沿，就发出<strong>电梯停稳</strong>信号</p>
</li>
<li>
<p>复位接触器和速度</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[win电脑更换动态壁纸以及鼠标样式]]></title>
        <id>https://Radiantzy.github.io/post/win-dian-nao-geng-huan-dong-tai-bi-zhi-yi-ji-shu-biao-yang-shi/</id>
        <link href="https://Radiantzy.github.io/post/win-dian-nao-geng-huan-dong-tai-bi-zhi-yi-ji-shu-biao-yang-shi/">
        </link>
        <updated>2021-07-10T07:06:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="元气壁纸">元气壁纸</h1>
<ul>
<li>提供4k壁纸</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://Radiantzy.github.io/post-images/1625897954415.png" alt="" loading="lazy"></figure>
<ul>
<li>动静态壁纸</li>
<li>（超级壁纸不能用嘞 ）</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://Radiantzy.github.io/post-images/1625897875583.png" alt="" loading="lazy"></figure>
<h2 id="元气壁纸下载">元气壁纸下载</h2>
<p><a href="https://pan.baidu.com/s/1CvXI0-MsS2VuRkUbjc05Ww">元气壁纸下载链接（298M）</a></p>
<p>提取码：7whq</p>
<h1 id="配置鼠标">配置鼠标</h1>
<ul>
<li>下载<a href="https://pan.baidu.com/s/1LhlP5nxn9GknBhT1TBjpJA">个人整理的鼠标样式</a>，提取码：1111，到本地，应该直接到网盘里面，然后找到你的网盘下载文件夹</li>
<li>点击左下角搜索，输入控制面板<img src="https://Radiantzy.github.io/post-images/1625900785094.png" alt="" loading="lazy"></li>
<li>点进去之后，这里输入鼠标<img src="https://Radiantzy.github.io/post-images/1625900840868.png" alt="" loading="lazy"></li>
<li>点击第二个</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://Radiantzy.github.io/post-images/1625900891809.png" alt="" loading="lazy"></figure>
<h1 id="鼠标样式下载">鼠标样式下载</h1>
<p>这里筛选了一些我个人感觉比较不错的，（大多数偏女生），还有一些极简主义的感觉不错的，回来我找找罗小黑跟裸熊的，简直不能再可爱了(●'◡'●)</p>
<p>这些俗气的鼠标样式名字都是自己取的hhhhhhhh</p>
<p>下面是一些例子：</p>
<h2 id="加了蓝色外壳的鼠标">加了蓝色外壳的鼠标</h2>
<figure data-type="image" tabindex="4"><img src="https://Radiantzy.github.io/post-images/1625898688872.png" alt="" loading="lazy"></figure>
<h2 id="极简主义">极简主义</h2>
<figure data-type="image" tabindex="5"><img src="https://Radiantzy.github.io/post-images/1625898888239.png" alt="" loading="lazy"></figure>
<h2 id="糯米团子">糯米团子</h2>
<figure data-type="image" tabindex="6"><img src="https://Radiantzy.github.io/post-images/1625899069657.png" alt="" loading="lazy"></figure>
<h2 id="彩色小白云">彩色小白云</h2>
<figure data-type="image" tabindex="7"><img src="https://Radiantzy.github.io/post-images/1625899199457.png" alt="" loading="lazy"></figure>
<h2 id="割绳子">割绳子</h2>
<figure data-type="image" tabindex="8"><img src="https://Radiantzy.github.io/post-images/1625899312451.png" alt="" loading="lazy"></figure>
<h2 id="小怪兽">小怪兽</h2>
<figure data-type="image" tabindex="9"><img src="https://Radiantzy.github.io/post-images/1625899473612.png" alt="" loading="lazy"></figure>
<h2 id="稍带点彩色的极简风">稍带点彩色的极简风</h2>
<figure data-type="image" tabindex="10"><img src="https://Radiantzy.github.io/post-images/1625899623029.png" alt="" loading="lazy"></figure>
<h2 id="结晶">结晶</h2>
<figure data-type="image" tabindex="11"><img src="https://Radiantzy.github.io/post-images/1625899803475.png" alt="" loading="lazy"></figure>
<h2 id="小樱鼠标">小樱鼠标</h2>
<ul>
<li>好吧，小樱鼠标样式感觉都一样，不过装上之后好看也是真的好看，淦！冲！</li>
</ul>
<figure data-type="image" tabindex="12"><img src="https://Radiantzy.github.io/post-images/1625899889008.png" alt="" loading="lazy"></figure>
<h2 id="胡萝卜">胡萝卜</h2>
<ul>
<li>胡萝卜的像素像我的世界里面的，不过很好配置啊，这点真的好爱啊</li>
</ul>
<figure data-type="image" tabindex="13"><img src="https://Radiantzy.github.io/post-images/1625900016142.png" alt="" loading="lazy"></figure>
<h2 id="黑色小猫">黑色小猫</h2>
<ul>
<li>这个不是特别全</li>
</ul>
<figure data-type="image" tabindex="14"><img src="https://Radiantzy.github.io/post-images/1625900237332.png" alt="" loading="lazy"></figure>
<h2 id="hello-kity">hello kity</h2>
<ul>
<li>像素一般，胜在全面，不过确实粉嫩啊</li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://Radiantzy.github.io/post-images/1625900338039.png" alt="" loading="lazy"></figure>
<h2 id="夏目友人帐">夏目友人帐</h2>
<ul>
<li>像素一般，但是很全</li>
</ul>
<figure data-type="image" tabindex="16"><img src="https://Radiantzy.github.io/post-images/1625900469744.png" alt="" loading="lazy"></figure>
<h2 id="黄色小猫">黄色小猫</h2>
<ul>
<li>基于我选择的动态壁纸，就选择这个当作我的鼠标样式了！</li>
</ul>
<figure data-type="image" tabindex="17"><img src="https://Radiantzy.github.io/post-images/1625900649154.png" alt="" loading="lazy"></figure>
<p>整理不易！！！！！！希望有别的鼠标资源可以贡献给我，然后我再整理出来！！！！！</p>
<h1 id="网站鼠标样式">网站鼠标样式</h1>
<p><a href="https://pan.baidu.com/s/1Jc-ym_7C4Hp6gZQfudXmXA">鼠标样式</a>，提取码：37dr。把这个.crx文件如下放置<br>
chrome&gt;更多设置&gt;拓展程序&gt;将该文件拖进去，就自己探索吧！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STM32串口控制舵机]]></title>
        <id>https://Radiantzy.github.io/post/stm32-chuan-kou-kong-zhi-duo-ji/</id>
        <link href="https://Radiantzy.github.io/post/stm32-chuan-kou-kong-zhi-duo-ji/">
        </link>
        <updated>2021-07-09T15:25:30.000Z</updated>
        <content type="html"><![CDATA[<p>首先我们要解决</p>
<h1 id="硬件问题">硬件问题：</h1>
<p><strong>舵机工作电压是多少？</strong> 一般供电范围是4.8V-6.0V电压，我这种舵机3V、5V不影响使用，个人觉得不要太大就行了。 <strong>舵机的三根线代表什么意思？</strong> 红色的是电源正极，黑色的是电源负极，白色的是信号线。有些舵机线是红棕橘三色，分别对应红黑白。 <strong>STM32开发板可以直接连接舵机吗？</strong> 有人可以直接连接，没有出现什么问题，但是有人可能会出现单片机复位的情况，可能是舵机瞬间驱动电流太大，使供电电压下降，引起单片机复位，我试验一下确实是电压太低了，舵机一开，电压就开始下降，从4点多降到3点多，最好还是分成两个电源，舵机一个，STM32一个，然后再把他们共地，单片机电压就会非常稳定，不会再复位。 <img src="https://img-blog.csdnimg.cn/20190629220555931.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0ODIxMw==,size_16,color_FFFFFF,t_70" alt="我通过一个稳压模块给舵机供电"> <strong>舵机发烫可能是什么问题？</strong> 接线接反了，或者是舵机受到阻碍了。</p>
<h1 id="舵机代码">舵机代码</h1>
<p><strong>我的代码总体框架是：</strong></p>
<pre><code>***PWM（主要）***

***LCD显示（次要）***

***串口改变占空比***

</code></pre>
<p><strong><strong>1、 PWM</strong></strong> 简单的配置就不说了。</p>
<pre><code>/*******************************************************************************
* 函 数 名         : TIM3_CH1_PWM_Init
* 函数功能		   : TIM3通道1 PWM初始化函数
* 输    入         : per:重装载值
					 psc:分频系数
* 输    出         : 无
*******************************************************************************/
void TIM3_CH1_PWM_Init(u16 per,u16 psc)
{&lt;!-- --&gt;
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_OCInitTypeDef TIM_OCInitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	
	/* 开启时钟 */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);
//	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
	
	/*  配置GPIO的模式和IO口 */
	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;//复用推挽输出
	GPIO_Init(GPIOA,&amp;amp;GPIO_InitStructure);
	
//	GPIO_PinRemapConfig(GPIO_FullRemap_TIM3,ENABLE);//改变指定管脚的映射	
	
	TIM_TimeBaseInitStructure.TIM_Period=per;   //自动装载值
	TIM_TimeBaseInitStructure.TIM_Prescaler=psc; //分频系数
	TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1;
	TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; //设置向上计数模式
	TIM_TimeBaseInit(TIM3,&amp;amp;TIM_TimeBaseInitStructure);	
	
	TIM_OCInitStructure.TIM_OCMode=TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OCPolarity=TIM_OCPolarity_High;
	TIM_OCInitStructure.TIM_OutputState=TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 10;							//确定占空比，这个值决定了有效电平的时间
	TIM_OC1Init(TIM3,&amp;amp;TIM_OCInitStructure); //输出比较通道1初始化
	
	TIM_OC1PreloadConfig(TIM3,TIM_OCPreload_Enable); //使能TIMx在 CCR1 上的预装载寄存器
	TIM_ARRPreloadConfig(TIM3,ENABLE);//使能预装载寄存器
	
	TIM_Cmd(TIM3,ENABLE); //使能定时器
		
}

</code></pre>
<p>接下来是设置自动装载值和分频系数，因为舵机的控制一般需要一个20ms左右的时基脉冲，我们需要一个20ms的PWM周期。</p>
<pre><code>TIM3_CH1_PWM_Init(200-1,7200-1);	

</code></pre>
<p>分频系数7200-1是什么意思？ 我们用的是TIM3，TIM3挂载在APB1时钟上。 <img src="https://img-blog.csdnimg.cn/20190629221023939.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0ODIxMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 默认情况下，系统和APB2都是72MHz，APB1是36MHz。 <img src="https://img-blog.csdnimg.cn/20190629221041552.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0ODIxMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 如果预分频系数不为1，那么定时器的时钟频率被设为与其相连的APB总线频率的2倍，所以TIM3的时钟频率应该算72MHz。那为什么要减1呢，因为它默认加1。1MHz的频率，脉冲周期就是1us，分频7200-1就是100us。 自动装载值200-1是什么意思？ 就是数到199就清零了，重新开始了，0~199就可以看做一个周期啦。这样一个周期就是200*100us=20ms。</p>
<pre><code>TIM_SetCompare1(TIM3, num);

</code></pre>
<p>这个函数用来设置占空比，只要计数比num小，就会产生有效的高电平。（由我们的配置决定的。） <img src="https://img-blog.csdnimg.cn/20190629221110501." alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/20190629221117643." alt="在这里插入图片描述"></p>
<h1 id="2-lcd显示次要">2、 LCD显示（次要）</h1>
<p>完成初始化后</p>
<pre><code>LCD_ShowNum(50,50,num,3,16);

</code></pre>
<p>显示占空比达到的值</p>
<h1 id="3-串口改变占空比">3、 串口改变占空比</h1>
<pre><code>/*******************************************************************************
* 函 数 名         : USART1_IRQHandler
* 函数功能		   : USART1中断函数
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/ 
void USART1_IRQHandler(void)                	//串口1中断服务程序
{&lt;!-- --&gt;
	u8 r;
	static char pwm[4];
	static int i=0;
	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断
	{&lt;!-- --&gt;
		r =USART_ReceiveData(USART1);//(USART1-&amp;gt;DR);	//读取接收到的数据
		if(r!=0x0D&amp;amp;&amp;amp;r!=0x0A)
		{&lt;!-- --&gt;
			pwm[i]=r;
			i++;
		}
		else
		{&lt;!-- --&gt;
			i=0;
			num=(atoi(pwm));
			TIM_SetCompare1(TIM3, num);
		}
		USART_SendData(USART1,r);
		while(USART_GetFlagStatus(USART1,USART_FLAG_TC) != SET);
	} 
	USART_ClearFlag(USART1,USART_FLAG_TC);
}

</code></pre>
<p>总的来说就是把ASCII码一个个接住储存在数组中，直到检测到回车键和换行键，把数组中的ASCII码变成一个数字，赋给num，从而改变占空比。</p>
<h1 id="实验">实验</h1>
<p><strong><strong>舵机最大最小可以转多少度？ 真的通过占空比改角度吗？</strong></strong> <img src="https://img-blog.csdnimg.cn/20190629223034728.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0ODIxMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 这是理论上高电平的周期可以实现舵机的角度，我们来试验一下。 一个脉冲周期是100us，那么5个就是500us=0.5ms。 <img src="https://img-blog.csdnimg.cn/20190629223056864." alt="在这里插入图片描述"> 我们在串口助手发送05，要记得加上回车，转换成16进制是这样的 <img src="https://img-blog.csdnimg.cn/20190629223109768." alt="在这里插入图片描述"> 舵机转成这样 <img src="https://img-blog.csdnimg.cn/20190629224353574.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0ODIxMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 在逻辑分析仪上观察到的PWM是这样的 <img src="https://img-blog.csdnimg.cn/20190629224407849." alt="在这里插入图片描述"> 周期是20ms，频率是50Hz，脉冲宽度500us，这就是我们所输出的PWM。 现在我们串口发送25， 舵机转成这样 <img src="https://img-blog.csdnimg.cn/20190629224423990.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0ODIxMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 在逻辑分析仪上观察到的PWM是这样的 <img src="https://img-blog.csdnimg.cn/20190629224439668." alt="在这里插入图片描述"> 尴尬了，我这个是270度的 <img src="https://img-blog.csdnimg.cn/20190629224454129.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0ODIxMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 市面有90-180-270-360度，觉得道理应该差不多的。 下面是main.c： <img src="https://img-blog.csdnimg.cn/20190629224534774.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0ODIxMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派笔记本当作显示屏操作]]></title>
        <id>https://Radiantzy.github.io/post/shu-mei-pai-bi-ji-ben-dang-zuo-xian-shi-ping-cao-zuo/</id>
        <link href="https://Radiantzy.github.io/post/shu-mei-pai-bi-ji-ben-dang-zuo-xian-shi-ping-cao-zuo/">
        </link>
        <updated>2021-06-09T12:03:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="所需零件和步骤">所需零件和步骤</h1>
<ul>
<li>需要树莓派一个，路由器一个，网线一条（用于连接路由器），笔记本一台，想用无线可以买多一个无线网卡，我觉得用无线网卡很方便，不用连着网线，想放哪里都行。</li>
<li>提前下载好需要的文件：树莓派的官网下载raspbian:https://www.raspberrypi.org/downloads/</li>
<li>格式化内存卡 SDFormatter：http://pan.baidu.com/s/1dDLMVq5</li>
<li>写入镜像 (14G,谨慎安装)win32diskimager ：http://pan.baidu.com/s/1bnWGhbx</li>
<li>利用putty进行ssh连接 ： http://pan.baidu.com/s/1dEp9iXN</li>
</ul>
<h1 id="安装系统">安装系统</h1>
<ul>
<li>下载完raspbian后，解压到电脑上没有中文字符的文件夹，得到.img镜像文件</li>
<li>下载SDFormatter后打开，格式化内存卡；</li>
<li>将TF卡（最少8G容量）插入读卡器，在电脑上打开 win32diskimager.exe，找到镜像，选好储存卡符，点击write写入镜像；大概需要几分钟时间，系统安装成功后会提示“Write Successful&quot;；这时在我的电脑TF卡只显示剩下几十M，这是正常的！由于TF卡在装了Linux系统后，分为三种格式，其中只有一种格式能被Windows系统识别，也就是剩下那几十M；然后把内存卡插进树莓派的插槽。</li>
</ul>
<h1 id="连接网络">连接网络</h1>
<ul>
<li>把网线接上树莓派，可以直接用安卓手机充电器给树莓派供电</li>
<li>在浏览器上打开路由器的后台，找到一个叫raspberrypi的IP，你也可以通过DHCP绑定IP，这样路由器分给树莓派的IP就只有一个了；然后打开putty，把刚才的IP地址写上去，也可以保存下来，方便下次登录</li>
<li>连接后，输入用户名pi，回车，输入密码raspberry,此时输入密码不会提示你是否输入，没有显示***字符，输完后回车，就进到树莓派的命令行了</li>
</ul>
<h1 id="连接笔记本">连接笔记本</h1>
<ul>
<li>
<p>强烈建议使用电脑自带的xrdp服务，当然用VNC也可以，在这里说的是安装xrdp;在命令行里输入<code>pi@raspberrypi:~ $ sudo apt-get install xrdp</code>后回车，等待安装，期间需要按Y继续；</p>
</li>
<li>
<p>安装完成后，在windows附件里找到远程桌面连接，打开后，输入刚才的IP地址，点击连接，连接后输入  用户名和密码  ，点击OK，就可以进到桌面了</p>
</li>
<li>
<p>实现树莓派远程桌面显示，安装VNC和xrdp</p>
</li>
</ul>
<p><code>sudo apt-get install vnc4server tightvncserver</code></p>
<p><code>sudo apt-get install xrdp</code></p>
<h1 id="配置">配置</h1>
<ul>
<li>点击红色箭头的位置</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://Radiantzy.github.io/post-images/1623240274155.png" alt="" loading="lazy"></figure>
<ul>
<li>输入<code>sudo raspi-config</code></li>
</ul>
<h1 id="配置步骤">配置步骤</h1>
<p>以下1、3、5步必须做，其他可做了解</p>
<ol>
<li>Expand Filesystem，将系统扩展到整个TF卡，必须执行，一路敲回车即可；</li>
<li>修改密码及账号，若要修改，请记住；</li>
<li>开机启动到桌面，或Scratch(编程寓教工具)；进入条目后，找到有“desktop”的条目，一路回车（以下设置完成后，重启即可自动进入桌面）；</li>
<li>在开机时等待网络；</li>
<li>地区/语言（汉化）：进入本项后，选择Change locale并进入，用键盘上下键找到en_GB.UTF-8 UTF-8，敲空格键去掉前面的*，依次找到 en_US.UTF-8 UTF-8、zh_CN UTF-8 UTF-8、  zh_CN GBK GBK，敲空格键打*，然后利用Tab键将光标移到OK，回车进入下一步。选择zh_CN UTF-8 UTF-8，再选OK，回车，等待几分钟。汉化至此完成；</li>
<li>启动PI的摄像头模块，如果想启用，选择Enable，禁用选择Disable就行了；</li>
<li>将树莓派加入Rastrack网站；</li>
<li>超频；一般不用超频，谨慎操作，提前做好散热，夏天散热量大；</li>
<li>高级选项，包括Overscan、Hostname、Memory Split（内存分配）、SSH、Spi、Update；</li>
<li>设置完成后，光标移到<Finish>，回车，自动重启。</li>
<li>Raspbian继承了Debian的一个毛病：就算选了默认中文，也不会自动安装中文字体。所以只设置系统支持中文，也无法马上显示汉字。进入桌面会出现乱码：</li>
<li>继续打开终端，在命令行上输入<code>sudo apt-get -y install ttf-wqy-zenhei</code>,不必理会乱码，命令跑完了重启，输入<code>sudo reboot</code>回车， 至此，中文系统就安装好了</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派：语音识别模块]]></title>
        <id>https://Radiantzy.github.io/post/shu-mei-pai-yu-yin-shi-bie-mo-kuai/</id>
        <link href="https://Radiantzy.github.io/post/shu-mei-pai-yu-yin-shi-bie-mo-kuai/">
        </link>
        <updated>2021-05-31T16:46:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="打开设备">打开设备</h1>
<p>TTL下载器插在USB接口上，在终端输入“ls/dev/tty”</p>
<p>代码如下：</p>
<pre><code class="language-c"> 1 # include &lt;stdio.h&gt;
 2 # include &lt;assert.h&gt;                        //测试函数
 3 # include &lt;string.h&gt;        
 4 # include &quot;Picustom.h&quot;                        //自定义头文件
 5 # define uint8 unsigned char                //宏定义
 6 # define N 124
 7 
 8 struct serial_port{
 9     char device[32];                          //设备路径
10     unsigned long baud;                      //波特率
11     int fd;                                 //设备描述符
12     unsigned char dates[1024];              //文件转存
13     unsigned char temp;                     //字符缓存
14     int len;                                //长度
15 };
16 
17 //字符串cp函数
18 char * my_strcpy(char *dest, const char *src){    //将源字符串加const，表明其为输入参数,起到相应的保护作用  
19    assert(src != NULL&amp;&amp;dest != NULL);            //对源地址和目的地址加非0断言  
20    char *ret = dest;  
21    while ((*dest++ = *src++));
22     return ret;                                    //引用返回地址，方便链式操作！！  
23 }
24 //清空serial
25 int clean_serial_port(struct serial_port *serial){
26     memset(serial-&gt;dates,0,1024);
27     serial-&gt;len = 0;
28     printf(&quot;\n&quot;);
29     return 0;
30 }
31 //字段尾部加0
32 int set_serial_dates_end(struct serial_port *serial){
33     if('\n' == serial-&gt;temp){    
34         printf(&quot;\n&quot;);
35         serial-&gt;dates[serial-&gt;len--]='\0';
36     }
37     return 0;
38 }
39 
40 //打印调试
41 int printf_serial_dates(struct serial_port *serial){
42     int i = 0;
43     if('\n' == serial-&gt;temp){
44         for(i = 0;i&lt;=serial-&gt;len;i++){
45             printf(&quot; %d---%x&quot;,i,serial-&gt;dates[i]);
46         }
47     }
48     return 0;
49 }
50 
51 //读取完成清空缓存0
52 int clean_serial(struct serial_port *serial){
53     if('\n' == serial-&gt;temp){        
54         clean_serial_port(serial);
55     }
56     return 0;
57 }
58 
59 
60 int main(void){
61     struct serial_port serial;
62     wiringPi(0,0);                                      //wiringPi初始化
63     serial.fd = init_serial_port(&quot;/dev/ttyUSB0&quot;,9600);    //通过树莓派函数打开
64     while(1){
65         serial.temp = Serial_data_read_char_10(serial.fd);
66         printf(&quot;%x\t&quot;,serial.temp);
67         if(((0xff &gt; serial.temp)&amp;&amp;(0x80 &lt; serial.temp))||(serial.temp == '\r')||(serial.temp == '\n')){
68             serial.dates[serial.len++] = serial.temp;
69             set_serial_dates_end(&amp;serial);        //尾部加0
70             //printf_serial_dates(&amp;serial);        //打印
71         
72         clean_serial(&amp;serial);                    //读取完成清空缓存0
73         }
74         else{                                    //出错清空缓存
75         clean_serial_port(&amp;serial);
76         }
77     }
78     return 0;
79 }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派与Auduino进行TCP协议通信]]></title>
        <id>https://Radiantzy.github.io/post/shu-mei-pai-yu-auduino-jin-xing-tcp-xie-yi-tong-xin/</id>
        <link href="https://Radiantzy.github.io/post/shu-mei-pai-yu-auduino-jin-xing-tcp-xie-yi-tong-xin/">
        </link>
        <updated>2021-05-31T16:19:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="将arduino作为服务端">将Arduino作为服务端</h1>
<pre><code class="language-c++">#include &lt;ESP8266WiFi.h&gt;

char ssid[] = &quot;1004&quot;;               /* wifi账号*/
char passwd[] = &quot;13609618951&quot;;      /* 密码*/
int port = 8888;                    /* 端口号*/
WiFiServer server(port);            /* 设置服务器端口*/

const byte open_data[] = {      /* 空调红外开码*/
0xFE, 0xFD, 0x03, 0x85, 0x01, 0xC3, 0x40, 0x39, 0x3F, 0x3B, 0x3D, 0x39, 0x3F, 0xAA, 0x3D, 0x3B, 0x3D, 0x39, 0x3F, 
0xAA, 0x3C, 0x39, 0x3F, 0xAA, 0x3D, 0x39, 0x3F, 0x3C, 0x3C, 0xAA, 0x3F, 0x37, 0x3F, 0x39, 0x41, 0x37, 0x3F, 0x39, 
0x3F, 0x3C, 0x3C, 0x39, 0x3F, 0x39, 0x3F, 0x3C, 0x3D, 0x38, 0x40, 0x38, 0x40, 0x3B, 0x3D, 0x39, 0x3F, 0x39, 0x3F,
0x39, 0x3F, 0x39, 0x3F, 0x39, 0x3F, 0xAA, 0x3F, 0x37, 0x3F, 0xAA, 0x3D, 0x38, 0x3F, 0x3C, 0x3C, 0xAA, 0x3D, 0x39,
0x3F, 0x07, 0xD4, 0x3F, 0x3A, 0x3F, 0x3B, 0x3D, 0x39, 0x3F, 0x3B, 0x3D, 0x3B, 0x3D, 0x3C, 0x3F, 0x39, 0x3C, 0x39, 
0x3F, 0x39, 0x40, 0x38, 0x40, 0x38, 0x40, 0x38, 0x40, 0x3B, 0x3D, 0x39, 0x3F, 0x39, 0x3F, 0x39, 0x3F, 0x39, 0x3F, 
0x3A, 0x41, 0x37, 0x3F, 0x39, 0x3F, 0x39, 0x3F, 0x39, 0x3F, 0x39, 0x3F, 0x3C, 0x3C, 0x39, 0x40, 0x38, 0x40, 0x39, 
0x3F, 0x39, 0x3F, 0xAA, 0x3D, 0xA9, 0x3D, 0x39, 0x3F, 0xAA, 0x3D, 0x0F, 0xA9, 0x03, 0x83, 0x01, 0xC3, 0x3F, 0x3C, 
0x3C, 0x3C, 0x3D, 0x3B, 0x3C, 0xAA, 0x3D, 0x39, 0x3F, 0x3C, 0x3C, 0xAA, 0x3D, 0x39, 0x3F, 0xAA, 0x3C, 0x3C, 0x3C, 
0x39, 0x40, 0xA9, 0x3D, 0x3B, 0x3D, 0x3C, 0x3C, 0x39, 0x3F, 0x39, 0x3F, 0x39, 0x3F, 0x3A, 0x3E, 0x3C, 0x3C, 0x3C, 
0x3D, 0x38, 0x40, 0x39, 0x3F, 0x39, 0x3F, 0x39, 0x3E, 0x39, 0x40, 0x38, 0x40, 0x3B, 0x3D, 0x39, 0x3F, 0xAA, 0x3D,
0xA9, 0x3D, 0xAA, 0x3C, 0x39, 0x3F, 0x3A, 0x3F, 0xA9, 0x3D, 0x39, 0x3F, 0x07, 0xD4, 0x40, 0x39, 0x3F, 0x39, 0x3F, 
0x3B, 0x3D, 0x3B, 0x3F, 0x3A, 0x3C, 0x39, 0x3F, 0x3C, 0x3C, 0x39, 0x3F, 0x39, 0x3F, 0x39, 0x40, 0x38, 0x3F, 0x3C, 
0x3D, 0x3B, 0x3D, 0x3B, 0x3D, 0x3B, 0x3D, 0x39, 0x3F, 0x39, 0x3F, 0x39, 0x40, 0x38, 0x40, 0x39, 0x3F, 0x3B, 0x3D, 
0x39, 0x3F, 0x39, 0x3F, 0x3B, 0x3D, 0xAA, 0x3D, 0xAA, 0x3C, 0x3C, 0x3C, 0x39, 0x3F, 0xAA, 0x3D, 0xAA, 0x3C, 0x39, 0x40, 0xA9, 0x3D, 0xFF 
};

const byte close_data[] = {     /* 空调红外关码*/
0xFE, 0xFD, 0x03, 0x85, 0x01, 0xC1, 0x41, 0x37, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 
0xA7, 0x40, 0x36, 0x42, 0xA7, 0x3F, 0x37, 0x41, 0x37, 0x41, 0xA8, 0x3F, 0x36, 0x42, 0x37, 0x41, 0x37, 0x41, 0x37, 
0x41, 0x37, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x37, 0x41, 0x37, 0x41, 0x37, 0x42, 0x36, 0x42, 0x36, 0x42, 
0x36, 0x41, 0x37, 0x42, 0x36, 0x42, 0xA7, 0x3F, 0x37, 0x42, 0xA7, 0x3F, 0x37, 0x41, 0x37, 0x41, 0xA8, 0x3F, 0x36, 
0x42, 0x07, 0xD3, 0x41, 0x37, 0x41, 0x37, 0x41, 0x37, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x37, 0x41, 0x37, 
0x41, 0x37, 0x41, 0x37, 0x42, 0x36, 0x42, 0x36, 0x42, 0x37, 0x41, 0x37, 0x41, 0x37, 0x41, 0x37, 0x42, 0x36, 0x42, 
0x36, 0x42, 0x36, 0x42, 0x37, 0x41, 0x37, 0x41, 0x37, 0x41, 0x37, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 
0x42, 0x36, 0x42, 0xA7, 0x40, 0xA7, 0x3F, 0x37, 0x41, 0x37, 0x42, 0x0F, 0xA8, 0x03, 0x85, 0x01, 0xC1, 0x42, 0x36, 
0x42, 0x36, 0x42, 0x36, 0x42, 0x37, 0x41, 0x37, 0x41, 0x36, 0x42, 0xA8, 0x3F, 0x36, 0x42, 0xA7, 0x3F, 0x37, 0x42, 
0x36, 0x42, 0xA7, 0x3F, 0x37, 0x41, 0x37, 0x41, 0x37, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x37, 0x41, 0x37, 
0x41, 0x37, 0x41, 0x37, 0x41, 0x37, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x37, 0x41, 0xA8, 0x3F, 
0xA7, 0x3F, 0xA8, 0x3F, 0x36, 0x42, 0x36, 0x42, 0xA7, 0x3F, 0x37, 0x42, 0x07, 0xD2, 0x41, 0x37, 0x41, 0x37, 0x42, 
0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x37, 0x41, 0x37, 0x41, 0x37, 0x41, 0x37, 0x42, 0x36, 
0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0x37, 0x41, 0x37, 0x41, 0x37, 0x41, 0x37, 0x42, 0x36, 0x42, 
0x36, 0x42, 0x36, 0x42, 0x36, 0x42, 0xA7, 0x40, 0xA7, 0x3F, 0x37, 0x41, 0x37, 0x41, 0xA8, 0x3F, 0xA7, 0x40, 0x36, 0x42, 0x36, 0x42, 0xFF 
};


void initWifi()     /* 建立Wifi网络模块*/
{
    WiFi.mode(WIFI_STA);            /* 设置为STA模式*/
    WiFi.begin(ssid, passwd);       /*输入wifi账号和密码*/

    while(WiFi.status() != WL_CONNECTED){
        Serial.print(&quot;.&quot;);
        delay(500);
    }

    Serial.println(WiFi.localIP());		/* 打印IP地址*/
    delay(500);

}

void setup()
{
    Serial.begin(115200);       /* 设置波特率*/
    initWifi();                 /* 初始化网络*/

}

void loop()
{
    char cmd;
    WiFiClient client = server.available();     /* 设置为服务端*/
    server.begin();     /* 服务端初始化*/
    

    while(client.connected()){          /* 检测是否连接*/
        while(client.available() &gt; 0){  /* 如果串口中有数据*/

            cmd = client.read();        /* 将串口中的数据传给cmd*/
            //Serial.println(cmd);      /* 打印cmd*/

            if(cmd == '1'){
             // Serial.println(&quot;1111111111&quot;); 
                Serial.write(open_data, (sizeof(open_data) / sizeof(open_data[0])));
            }
            if(cmd == '2'){
             // Serial.println(&quot;22222222&quot;);
                Serial.write(close_data, (sizeof(close_data) / sizeof(close_data[0])));
            }
        }
    }

}



</code></pre>
<h1 id="树莓派作为客户端">树莓派作为客户端</h1>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;arpa/inet.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
#include&lt;wiringSerial.h&gt;
#include&lt;unistd.h&gt;
#include&lt;string.h&gt;
#include&lt;wiringPi.h&gt;

int main(int argc, char *argv[])
{
    int fd;
    int c_fd;
    int ret;
    char cmd[128] = {'\0'};
    char a = '1';
    char b = '2';

    if(argc != 3){
        printf(&quot;input params error!\n&quot;);
        exit(0);
    }

    wiringPiSetup();        /* 硬件初始化，使用wiringPi引脚*/
    fd = serialOpen(&quot;/dev/ttyAMA0&quot;, 9600);      /* 打开串口*/
    if(fd == -1) {
        perror(&quot;open failed&quot;);
        exit(-1);
    }

    /* 创建网络套接字*/
    c_fd = socket(AF_INET, SOCK_STREAM, 0);
    if(c_fd == -1){
        perror(&quot;socket failed!\n&quot;);
        exit(-1);
    }

    /* 建立连接*/
    struct sockaddr_in addr;
    memset(&amp;addr, 0, sizeof(addr));

    addr.sin_family = AF_INET;                  /* 设置IP协议*/
    addr.sin_port = htons(atoi(argv[2]));       /* 传递端口号，从网络（大端）到主机（小端）*/
    inet_aton(argv[1], &amp;addr.sin_addr);         /* 传递IP地址*/

    ret = connect(c_fd, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr));
    if(ret == -1) {
        perror(&quot;connect wemos failed!\n&quot;);
        exit(-1);
    }else{
        printf(&quot;connected successfully\n&quot;);
    }

    while(1){
       
        read(fd, cmd, sizeof(cmd));     /* 读取语音模块发送的指令*/
        
        if(strstr(cmd,&quot;open&quot;)){
            printf(&quot;accept open\n&quot;);
            write(c_fd, &amp;a, sizeof(char));
        }

        if(strstr(cmd,&quot;close&quot;)){
            printf(&quot;accept close\n&quot;);
            write(c_fd, &amp;b, sizeof(char));
        }
        
        printf(&quot;cmd:%s&quot;,cmd);
		memset(cmd, '\0', sizeof(cmd) / sizeof(char));
        serialFlush(fd);                /* 刷新缓冲区数据*/
        delay(200);
    }

    return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派的一些命令与红外调试]]></title>
        <id>https://Radiantzy.github.io/post/shu-mei-pai-de-yi-xie-ming-ling-yu-hong-wai-diao-shi/</id>
        <link href="https://Radiantzy.github.io/post/shu-mei-pai-de-yi-xie-ming-ling-yu-hong-wai-diao-shi/">
        </link>
        <updated>2021-05-31T14:14:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="树莓派的gpio口">树莓派的GPIO口</h1>
<figure data-type="image" tabindex="1"><img src="https://Radiantzy.github.io/post-images/1622470500443.png" alt="" loading="lazy"></figure>
<h1 id="树莓派的一些命令">树莓派的一些命令</h1>
<ul>
<li>升级树莓派软件</li>
</ul>
<pre><code class="language-python">sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade

sudo apt-get upgrade
</code></pre>
<ul>
<li>安装LIRC-LINUX Infrared Remote Control</li>
</ul>
<p><strong>LIRC</strong>:开源的用来控制树莓派接收和发射红外信号的软件</p>
<pre><code class="language-python">sudo apt-get install lirc
</code></pre>
<ul>
<li>编辑我们自己的 /etc/modules文件，加入以下代码</li>
</ul>
<pre><code class="language-python">lirc_dev
lirc_rpi gpio_in_pin=23 gpio_out_pin=22
</code></pre>
<ul>
<li>修改/etc/lirc/hardware.conf文件，如下（****部分为需要修改的地方）</li>
</ul>
<pre><code class="language-python">LIRCD_ARGS=&quot;--**uinput**&quot;

# Don't start lircmd even if there seems to be a good config file
# START_LIRCMD=false

# Don't start irexec, even if a good config file seems to exist.
# START_IREXEC=false

# Try to load appropriate kernel modules
LOAD_MODULES=**true**

# Run &quot;lircd --driver=help&quot; for a list of supported drivers.
DRIVER=&quot;default&quot;

# usually /dev/lirc0 is the correct setting for systems using udev
DEVICE=&quot;**/dev/lirc0**&quot;
MODULES=&quot;**lirc_rpi**&quot;

# Default configuration files for your hardware if any
LIRCD_CONF=&quot;&quot;
LIRCMD_CONF=&quot;&quot;
</code></pre>
<ul>
<li>红外接收器的电压数，大部分是3V的。插的时候理论上可以支持热插拔，但保险起见建议将树莓派关机断电之后进行操作.对于大部分红外接收器来说，接法是</li>
</ul>
<blockquote>
<p>vcc 连 pin1 (3.3v)<br>
gnd 连 pin6(ground)<br>
data连 pin12(gpio18)</p>
</blockquote>
<h2 id="调试红外接收器">调试红外接收器</h2>
<ul>
<li>开机后，加载lirc模块</li>
</ul>
<pre><code class="language-python">sudo modprobe lirc_rpi
</code></pre>
<ul>
<li>然后结束lrcd进程</li>
</ul>
<pre><code class="language-python">sudo kill $(pidof lircd)
</code></pre>
<ul>
<li>启动测试</li>
</ul>
<pre><code class="language-python">sudo mode2 -d /dev/lirc0
</code></pre>
<ul>
<li>红外接收器已经打开，处于监听状态。这个时候，利用任何红外发射器（可以是电视遥控器或其他遥控器）对红外接收模块按任意按钮，就可以在树莓派终端上看到类似如下的代码，看到这个代码便证明红外接收模块是正常工作的。如果没有看到，请检查你的接线、电压、以及通过lsusb查看是否加载了相应模块。</li>
</ul>
<h2 id="配置红外发射器">配置红外发射器</h2>
<ul>
<li>首先清除接收器指令</li>
</ul>
<pre><code class="language-python">sudo kill $(pidof lircd)
</code></pre>
<ul>
<li>列出接收器常用的指令，挑选其中自己需要的指令，记住便可</li>
</ul>
<pre><code class="language-python">sudo irrecord --list-namespace
</code></pre>
<ul>
<li>一般常用的指令可能是这些</li>
</ul>
<pre><code class="language-python">KEY_UP
KEY_DOWN
KEY_LEFT
KEY_RIGHT
KEY_ESC
KEY_ENTER
KEY_SPACE
</code></pre>
<ul>
<li>再次清除接收器指令</li>
</ul>
<pre><code class="language-python">sudo kill $(pidof lircd)
</code></pre>
<ul>
<li>打开红外接收器</li>
</ul>
<pre><code class="language-python">irrecord -d /dev/lirc0 ~/lircd.conf
</code></pre>
<ul>
<li>按照指示，请先按enter二次，再按住你的遥控器任意键，直到屏幕上的...................跑完。<br>
跑完后，你刚刚按住的那个键，请一直重覆按，直到屏幕上的...................跑完。</li>
</ul>
<h2 id="设定参数">设定参数</h2>
<ul>
<li>
<p>先输入<strong>KEY_UP</strong>然后按遥控器上按你要设定为 上 的那个键，然后再按<strong>ENTER</strong>。<br>
再输入<strong>KEY_DOWN</strong>然后按遥控器上按你要设定为 下 的那个键，然后再按<strong>ENTER</strong>。</p>
<p>重复上述动作，一直到设定完成，最后按enter离开。<br>
　　以上完成了红外信号录入的动作，之后你将可以在**/home/pi/lircd.conf**文件中看到你刚才录入的红外信号。</p>
</li>
</ul>
<h2 id="配置红外发射器-2">配置红外发射器</h2>
<ul>
<li>首先关闭树莓派将红外发射器接到对应的GPIO口上，对于大部分红外接收器来说，接法是</li>
</ul>
<pre><code class="language-python">vcc 连pin2(5v)
gnd连pin6(ground)
data连pin11(gpio17)
</code></pre>
<ul>
<li>更改LIRC配置文件，将xxx替代为你自定义的名字。</li>
</ul>
<pre><code class="language-python">sudo cp ~/lircd.conf /etc/lirc/xxx.conf
</code></pre>
<ul>
<li>编辑/etc/lirc/xxx.conf文件，将<strong>name ***/lircd.conf</strong> 更改为 <strong>name xxx</strong>，这里的xxx需要与上面的一致</li>
<li>进行测试，将xxx替代为前面定义的文字，并且执行定义好的按钮KEY_UP, KEY_DOWN等</li>
</ul>
<pre><code class="language-python">sudo irsend SEND_ONCE xxx KEY_UP
sudo irsend SEND_ONCE xxx KEY_DOWN
sudo irsend SEND_ONCE xxx KEY_LEFT
sudo irsend SEND_ONCE xxx KEY_RIGHT
sudo irsend SEND_ONCE xxx KEY_ENTER
</code></pre>
<ul>
<li>现在可以使用家庭电视遥控器或其他红外遥控器的按钮录入树莓派，然后最后用irsend命令来测试这个红外信号是否成功发射</li>
<li><strong>前提是</strong>，这个家庭设备需要和插座之间再接一个红外插座，通过控制这个红外插座的开合，来对家庭设备做间接的控制。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派：烟雾报警装置]]></title>
        <id>https://Radiantzy.github.io/post/shu-mei-pai-yan-wu-bao-jing-zhuang-zhi/</id>
        <link href="https://Radiantzy.github.io/post/shu-mei-pai-yan-wu-bao-jing-zhuang-zhi/">
        </link>
        <updated>2021-05-31T14:04:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="组件">组件</h1>
<ul>
<li>Rasberry Pi主板</li>
<li>树莓派电源</li>
<li>40P软排线</li>
<li>PCF8591模数转换器模块</li>
<li>烟雾传感器模块</li>
<li>有源蜂鸣器模块</li>
<li>面包板</li>
<li>跳线</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://Radiantzy.github.io/post-images/1622464847957.webp" alt="" loading="lazy"></figure>
<p>烟雾传感器模块原理图</p>
<p><strong>MQ-2</strong>气体传感器：使用氧化锡半导体气敏材料。当环境温度在200-300℃时，氧化锡会吸附空气中的氧气并形成氧阴离子吸附，从而降低半导体中的电子密度，从而增加其电阻。当与烟雾接触时，如果晶界阻挡层被烟雾调制并发生变化，则可能导致表面电导率发生变化。因此可以获得烟雾存在的信息，烟雾浓度越高，材料的导电性越高，因此输出电阻越低。若有害气体达到一定浓度，蜂鸣器会发出蜂鸣声警告。</p>
<p>烟雾报警传感器有两个LED指示灯。POWER-LED是电源指示灯，接通电源后常亮。DOUT-LED是数字输出指示灯，当没有检测到烟雾时熄灭，DO输出高电平；当检测到烟雾时，DO输出低电平，DOUT-LED指示灯亮。而判定是否有烟雾的临界值可以通过旋转蓝色元件上的十字螺丝调节，调节到没有烟雾时DOUT-LED灯刚好熄灭时即可。</p>
<h1 id="实验步骤">实验步骤</h1>
<h2 id="连接电路">连接电路</h2>
<p>有源蜂鸣器使用的电源为3.3V，烟雾传感器使用的是5V</p>
<table>
<thead>
<tr>
<th>树莓派</th>
<th>T型转接板</th>
<th>PCF8591模块</th>
</tr>
</thead>
<tbody>
<tr>
<td>SDA(串行数据线)</td>
<td>SDA</td>
<td>SDA</td>
</tr>
<tr>
<td>SCL（串行时钟线）</td>
<td>SCL</td>
<td>SCL</td>
</tr>
<tr>
<td>5V</td>
<td>5V</td>
<td>VCC</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
<td>GND</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>烟雾传感器模块</th>
<th>T型转接板</th>
<th>PCF8591模块</th>
</tr>
</thead>
<tbody>
<tr>
<td>AO</td>
<td>*</td>
<td>AIN0</td>
</tr>
<tr>
<td>DO</td>
<td>G17</td>
<td>*</td>
</tr>
<tr>
<td>VCC</td>
<td>5V</td>
<td>VCC</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
<td>GND</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>有源蜂鸣器</th>
<th>T型转接板</th>
</tr>
</thead>
<tbody>
<tr>
<td>I/O</td>
<td>G18</td>
</tr>
<tr>
<td>VCC</td>
<td>3.3V</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
</tbody>
</table>
<h2 id="开始编程">开始编程</h2>
<ul>
<li>
<p>PCF8591模块采用的是I2C（IIC）总线通信，但在树莓派的镜像中默认是关闭的，在使用该传感器的时候，我们必须首先允许IIC总线通信。</p>
</li>
<li>
<p>PCF8591.py库文件就是PCF8591模块的程序，单独编写是为了便于重用。在此py文件使用了一个放大器用于模拟输入和一个LED灯用于模拟输出，模拟输入不能超过3.3V<br>
 该程序也可以单独运行，用于测试3个电阻模块的功能。需用短路帽连接AIN0和INPUT0（电位计模块），连接AIN1和INPUT1（光敏电阻模块），以及连接AIN2和INPUT2（热敏电阻模块）。<br>
 连接LED灯，AIN0（模拟输入0）端口用于接收来自电位计模块的模拟信号，AOUT（模拟输出）用于将模拟信号输出到双色LED模块，以便改变LED的亮度。</p>
</li>
<li>
<p>PCF8591.py文件参考：</p>
</li>
</ul>
<pre><code class="language-python">#!/usr/bin/env python
#------------------------------------------------------
#
#       可以使用下面语句将此脚本导入另一个脚本：
#           “import PCF8591 as ADC”                
#   
#   ADC.Setup(Address)  # 查询PCF8591的地址：“sudo i2cdetect -y 1”
# i2cdetect  is  a  userspace  program to scan an I2C bus for devices.
# It outputs a table with the list of detected devices on the specified bus.
#   ADC.read(channal)   # Channal范围从0到3 
#   ADC.write(Value)    # Value范围从0到255
#
#------------------------------------------------------
#SMBus (System Management Bus,系统管理总线) 
import smbus   #在程序中导入“smbus”模块
import time

# for RPI version 1, use &quot;bus = smbus.SMBus(1)&quot;
# 0 代表 /dev/i2c-0， 1 代表 /dev/i2c-1 ,具体看使用的树莓派那个I2C来决定
bus = smbus.SMBus(1)         #创建一个smbus实例

#在树莓派上查询PCF8591的地址：“sudo i2cdetect -y 1”
def setup(Addr):
    global address
    address = Addr

def read(chn): #channel
    if chn == 0:
        bus.write_byte(address,0x40)   #发送一个控制字节到设备
    if chn == 1:
        bus.write_byte(address,0x41)
    if chn == 2:
        bus.write_byte(address,0x42)
    if chn == 3:
        bus.write_byte(address,0x43)
    bus.read_byte(address)         # 从设备读取单个字节，而不指定设备寄存器。
    return bus.read_byte(address)  #返回某通道输入的模拟值A/D转换后的数字值

def write(val):
    temp = val  # 将字符串值移动到temp
    temp = int(temp) # 将字符串改为整数类型
    # print temp to see on terminal else comment out
    bus.write_byte_data(address, 0x40, temp) 
    #写入字节数据，将数字值转化成模拟值从AOUT输出

if __name__ == &quot;__main__&quot;:
    setup(0x48) 
 #在树莓派终端上使用命令“sudo i2cdetect -y 1”，查询出PCF8591的地址为0x48
    while True:
        print '电位计   AIN0 = ', read(0)   #电位计模拟信号转化的数字值
        print '光敏电阻 AIN1 = ', read(1)   #光敏电阻模拟信号转化的数字
        print '热敏电阻 AIN2 = ', read(2)   #热敏电阻模拟信号转化的数字值
        tmp = read(0)
        tmp = tmp*(255-125)/255+125 
# 125以下LED不会亮，所以将“0-255”转换为“125-255”，调节亮度时灯不会熄灭
        write(tmp)
        time.sleep(2)

</code></pre>
<h2 id="编写控制程序">编写控制程序</h2>
<p>编写控制程序。通过点烟的方式产生可燃性气体靠近MQ-2气体传感器的位置。屏幕上将显示0到255之间的值。如果有害气体达到一定浓度，蜂鸣器会发出断续蜂鸣声，并且屏幕上会印有“Danger Gas”。<br>
 你可以转动模块上电位器的轴来提高或降低浓度阈值。<br>
 MQ-2气体传感器需要加热一段时间。等到屏幕上打印的值保持稳定并且传感器变热，这意味着它可以正常且敏感的工作。(<strong>气体传感器发热是正常的，实际上，温度越高传感器就越敏感。</strong>)</p>
<p>主程序：</p>
<pre><code class="language-python">#!/usr/bin/env python
import PCF8591 as ADC
import RPi.GPIO as GPIO
import time
import math

DO = 17
Buzz = 18
GPIO.setmode(GPIO.BCM)

def setup():
    ADC.setup(0x48)
    GPIO.setup  (DO,    GPIO.IN)
    GPIO.setup  (Buzz,  GPIO.OUT)
    GPIO.output (Buzz,  1)  #高电平不响，低电平触发报警蜂鸣

def Print(x):
    if x == 1:
        print ''
        print '   *********'
        print '   * Safe~ *'
        print '   *********'
        print ''
    if x == 0:
        print ''
        print '   ***************'
        print '   * Danger Gas! *'
        print '   ***************'
        print ''

def loop():
    status = 1
    count = 0
    while True:
        print 'ADC.read(0)==' , ADC.read(0)  #有烟雾时，该值增大
        
        tmp = GPIO.input(DO);
        print 'tmp==' ,tmp    
#无烟雾时为高电平，tmp=1,打印safe，有烟雾时为低电平，打印Danger Gas！
        if tmp != status:
            Print(tmp)
            status = tmp
        if status == 0:
            count += 1
            if count % 2 == 0:
                GPIO.output(Buzz, 0)  #检测到烟雾后，报警声为断续蜂鸣声，低电平为响
            else:
                GPIO.output(Buzz, 1)  #高电平不响
        else:
            GPIO.output(Buzz, 1)
            count = 0
                
        time.sleep(0.2)

def destroy():
    GPIO.output(Buzz, 1)
    GPIO.cleanup()

if __name__ == '__main__':
    try:
        setup()
        loop()
    except KeyboardInterrupt: 
        destroy()


</code></pre>
<h2 id="pcf8591模数转换器">PCF8591模数转换器</h2>
<p>PCF8591原理图</p>
<figure data-type="image" tabindex="2"><img src="https://Radiantzy.github.io/post-images/1622468843370.webp" alt="" loading="lazy"></figure>
<p>实物图：</p>
<figure data-type="image" tabindex="3"><img src="https://Radiantzy.github.io/post-images/1622468869035.webp" alt="" loading="lazy"></figure>
<p><strong>右边JP1， 5对接口：</strong></p>
<ul>
<li>AOUT 芯片DA输出接口<br>
 AINO 芯片模拟输入接口0<br>
 AIN1 芯片模拟输入接口1<br>
 AIN2 芯片模拟输入接口2<br>
 AIN3 芯片模拟输入接口3<br>
右排是：<br>
 GND 接地<br>
 GND 接地<br>
 INPUT2 热敏电阻接口<br>
 INPUT1 光敏电阻接口<br>
 INPUT0 电位计接口<br>
<strong>左边J1， 4个接口：</strong><br>
 SCL  IIC时钟接口  接树莓派的scl口（接树莓派 I2C1 SCL口）<br>
 SDA  IIC数字接口  接树莓派的sda口（接单树莓派 I2C1 SDA口）<br>
 GND  模块地       外接地（接树莓派GND）<br>
 VCC  电源接口     外接3.3v-5v  （接树莓派电源）<br>
这里用的是5V。</li>
</ul>
<p>对应的端口分别作用如下：<br>
INPUT0端口   用短路帽接上AIN0，选择0-5V可调电压接入电路</p>
<p>INPUT1端口   用短路帽接上AIN1，选择光敏电阻接入电路</p>
<p>INPUT2端口   用短路帽接上AIN2，选择热敏电阻接入电路</p>
<ul>
<li>
<p>AIN0～AIN3：模拟信号输入端。</p>
<p>A0～A3：引脚地址端。</p>
<p>VDD、VSS：电源端（2.5～6V）</p>
<p>SDA、SCL：I2C总线的数据线、时钟线。</p>
<p>OSC：外部时钟输入端，内部时钟输出端。</p>
<p>EXT：内部、外部时钟选择线，使用内部时钟时EXT接地。</p>
<p>AGND：模拟信号地。</p>
<p>AOUT：D/A转换输出端。</p>
<p>VREF：基准电源端。</p>
</li>
<li>
<p><strong>AD的位数</strong>：表明这个AD共有2n个刻度，8位AD，输出的刻度是0~255.  8591就是8为精度的，因此它digtalRead的数据在0-255之间。<br>
<strong>分辨率</strong>：就是AD能够分辨的最小的模拟量变化，假设5.10V的系统用8位的AD采样，那么它能分辨的最小电压就是5.10/255=0.02V。</p>
</li>
<li>
<p>AD转换的原理简单来理解就是通过电路将非电信号转为电信号，然后通过一个基准电压（PCF8591的基准电压是5V），然后判断这个电信号的电压高低，然后得到一个0-255（8位精度）的比值。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[蓝牙模块]]></title>
        <id>https://Radiantzy.github.io/post/lan-ya-mo-kuai/</id>
        <link href="https://Radiantzy.github.io/post/lan-ya-mo-kuai/">
        </link>
        <updated>2021-05-31T02:51:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="经典蓝牙bt">经典蓝牙BT</h1>
<ul>
<li>蓝牙协议4.0以下的模块</li>
<li>数据量较大的传输，如语音，音乐等
<ul>
<li>传统蓝牙模块</li>
<li>高速蓝牙模块（传输速率约24Mbps)</li>
</ul>
</li>
</ul>
<h1 id="低功耗蓝牙ble">低功耗蓝牙BLE</h1>
<ul>
<li>蓝牙协议4.0或更高的模块</li>
<li>成本和低功耗，适用于实时性要求比较高的产品（智能家居或消费电子）</li>
</ul>
<h2 id="hc-08-usb蓝牙模块">HC-08-USB蓝牙模块</h2>
<ul>
<li>通信协议4.0，工作频段2.4G，通信距离80m，空中速率1mbps，产品尺寸58*21*10mm，嵌入方式USB2.0，有HC08配套的PC端虚拟串口</li>
</ul>
<h2 id="广州汇承hc-08-蓝牙40-ble串口模块">广州汇承HC-08 蓝牙4.0 BLE串口模块</h2>
<ul>
<li>调制方式GFSK，模块最大发射功率4dbm,接收灵敏度-93dBm，尺寸26.9mm*13mm*2.2mm集成邮票封装孔和排针焊接孔，既可以贴片封装，又可以焊接排针，自带LED状态指示灯，可只管判断蓝牙的连接状态</li>
</ul>
<h2 id="mlt-bt05-40蓝牙模块">MLT-BT05 4.0蓝牙模块</h2>
<p>蓝牙串口模块指令为command指令集，发AT指令必须回车换行，（<strong>AT指令只能在模块未连接状态下才能生效，一旦蓝牙模块与设备连接上，蓝牙模块即进入数据透传</strong>）选能支持AT指令的板</p>
<figure data-type="image" tabindex="1"><img src="https://Radiantzy.github.io/post-images/1622429315256.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://Radiantzy.github.io/post-images/1622429474285.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://Radiantzy.github.io/post-images/1622429526524.png" alt="" loading="lazy"></figure>
<p>HC08直接连接电脑需借助HC-08-USB蓝牙虚拟串口与电脑相连</p>
<h1 id="蓝牙配置">蓝牙配置</h1>
<h2 id="硬件连接">硬件连接</h2>
<ul>
<li>VCC：接电源正极（3.3-5V）</li>
<li>GND：接电源负极</li>
<li>RXD：接收端，接收从其他设备发来的数据（一般接其他设备的发送端TXD）</li>
<li>STATE：状态端</li>
<li>EN：使能端。需要进入AT模式时接3.3V
<ul>
<li>需要注意<strong>这里是按住按键进入AT模式，直接给EN端接3.3V是进不去AT模式的，通过电平进入AT模式正确的做法应该是设置PIO11引脚的电平，而不是EN端的电平</strong></li>
</ul>
</li>
</ul>
<h2 id="进入at模式">进入AT模式</h2>
<p>USB转TTL和蓝牙模块连接好后，插上电脑，进入AT模式的两种方法：</p>
<ul>
<li>按住按键不放，再给模块上电，LED此时2s闪一次，进入AT模式，波特率固定为38400</li>
<li>模块直接上电，LED此时快闪（1s两次）再按下按键，模块也会进入AT指令，LED仍是快闪，波特率和自己设置的一样，默认为9600，1位停止位，无奇偶校验</li>
</ul>
<p>AT指令用来设置模块的参数，在未连接状态下进行AT指令操作，连线后进入串口透传模式。</p>
<ul>
<li>常用AT指令</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://Radiantzy.github.io/post-images/1622430541822.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[stm32cubemx学习记录之GPIO输出跑马灯]]></title>
        <id>https://Radiantzy.github.io/post/stm32cubemx-xue-xi-ji-lu-zhi-gpio-shu-chu-pao-ma-deng/</id>
        <link href="https://Radiantzy.github.io/post/stm32cubemx-xue-xi-ji-lu-zhi-gpio-shu-chu-pao-ma-deng/">
        </link>
        <updated>2021-03-20T13:36:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="软件下载链接">软件下载链接</h1>
<p>stm32cubemx:https://pan.baidu.com/s/1ncKMjvzQGqy6NFZWENm-MQ</p>
<p>提取码：siec</p>
<p>java环境（<strong>必装，不然没办法生成代码</strong>）：https://pan.baidu.com/s/17JQ06w5lO0Imzx2czrgnBQ<br>
提取码：uyu1</p>
<ul>
<li>我给的链接是<strong>win6.2.0</strong>，算是比较新的版本，可以直接下。</li>
<li>跑马灯实例基于固件库<strong>STM32Cube FW_F1 V1.6.1</strong></li>
</ul>
<p>STCdemo III：https://pan.baidu.com/s/1pjH__TVuhS32yOY9qk5hSg<br>
提取码：du2t<br>
复制这段内容后打开百度网盘手机App，操作更方便哦</p>
<h1 id="新建项目">新建项目</h1>
<figure data-type="image" tabindex="1"><img src="https://Radiantzy.github.io/post-images/1616245254021.png" alt="" loading="lazy"></figure>
<ul>
<li>在stm32cubemx里面新建项目，选择正确的mcu型号，这里我们选择<strong>STM32F103RETx</strong></li>
<li>设置RCC和SYS</li>
</ul>
<blockquote>
<p>RCC:arm里面复位与时钟控制器的缩写</p>
<ul>
<li>
<p>系统复位：复位除了时钟控制寄存器CSR中的复位标志和备份区域中的寄存器以外的所有寄存器</p>
<ul>
<li>
<p>以下事情的一件发生产生一个系统复位</p>
<ul>
<li>NRST管脚的低电平（外部复位）</li>
<li>窗口看门狗计数终止（WWDG复位）</li>
<li>独立看门狗计数终止（IWDG复位）</li>
<li>软件复位（SW复位）</li>
<li>低功耗管理复位</li>
</ul>
<p>可通过查看RCC_CSR控制状态寄存器中的复位标志位识别复位事件来源</p>
</li>
</ul>
</li>
<li>
<p>电源复位：将复位除了备份区域外的所有寄存器</p>
<ul>
<li>
<p>以下事情的一件发生产生一个电源复位</p>
<ul>
<li>上电/掉电复位（POR/PDR复位）</li>
<li>从待机模式中返回</li>
</ul>
<p>复位源将最终作用于RESET管脚，并在复位中保持低电平。复位入口矢量被固定在地址０ｘ００００＿０００４</p>
</li>
</ul>
</li>
<li>
<p>时钟</p>
<ul>
<li>
<p>三种不同的时钟源可被用来驱动系统时钟（SYSCLK）</p>
<ul>
<li>HSL振荡器时钟</li>
<li>HSE振荡器时钟</li>
<li>PLL时钟</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>SYS:中断</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://Radiantzy.github.io/post-images/1616245303335.png" alt="" loading="lazy"></figure>
<p>设置如下图</p>
<ul>
<li>根据板子实际情况设置时钟（stm32F103x的最高主频是72M）</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://Radiantzy.github.io/post-images/1616246979568.png" alt="" loading="lazy"></figure>
<ul>
<li>GPIO设置PC7,PC8,PA12和PC10为GPIO_OUTPUT</li>
</ul>
<p>直接点击板子上的接口就可以设置,配置如下</p>
<figure data-type="image" tabindex="4"><img src="https://Radiantzy.github.io/post-images/1616247026603.png" alt="" loading="lazy"></figure>
<ul>
<li>Project-setting,ToolChain/IDE选择MDK-ARM，注意<strong>项目名称不能有空格，最好不要有中文</strong></li>
</ul>
<p><img src="https://Radiantzy.github.io/post-images/1616643670050.png" alt="" loading="lazy"><br>
<strong>注意那个min version看看自己keil里面的版本，具体操作如下：</strong><br>
<img src="https://Radiantzy.github.io/post-images/1616643845045.png" alt="" loading="lazy"><br>
打开help里面的about<br>
<img src="https://Radiantzy.github.io/post-images/1616643874083.png" alt="" loading="lazy"><br>
上面那个号就是我们的版本号，如图我的是5.14，所以取最小勾选5<br>
切换到Project Manager</p>
<p>勾选如下</p>
<figure data-type="image" tabindex="5"><img src="https://Radiantzy.github.io/post-images/1616247181809.png" alt="" loading="lazy"></figure>
<h1 id="运行">运行</h1>
<p>一切都配置好之后，点右上角的generate code（生成代码）那么我们就可以得到我们想要的代码块，会自己调用，再修改接口完成我们所需操作。</p>
<p>我们可以直接在keil5里面打开（依赖于之前选的MDK-ARM）。如下图</p>
<figure data-type="image" tabindex="6"><img src="https://Radiantzy.github.io/post-images/1616247347404.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>